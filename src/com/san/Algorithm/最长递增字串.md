### 最长递增子串
#### 动态规划
* 定义状态
    * dp[i] 表示前i个数最长子列长度
* 状态方程
    1. 当nums[i] > nums[j]时,nums[i] 可以接在 nums[j]nums[j] 之后,此情况下最长上升子序列长度为 dp[j] + 1dp[j]+1 ;
    2. 当nums[i] <= nums[j]时,不存在,不成立;
    * 下计算出的 dp[j] + 1dp[j]+1 的最大值，为直到 ii 的最长上升子序列长度(即dp[i])。实现方式为遍历j时，每轮执行 dp[i] = max(dp[i], dp[j] + 1)
    * #### 转移方程：dp[i] = max(dp[i], dp[j] + 1);
* 初始状态
    * dp[i] 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为1。
* 返回值
    * 返回 dp 列表最大值，即可得到全局最长上升子序列长度。
* 复杂度
    * #### 时间复杂度：O(N²)
    * #### 空间复杂度：O(N)




